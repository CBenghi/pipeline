// Copyright NVIDIA Corporation 2002-2009
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//  * Neither the name of NVIDIA CORPORATION nor the names of its
//    contributors may be used to endorse or promote products derived
//    from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

const char effectLump[] =
  "\r\n"
  "float4x4 worldvp : WorldViewProjection;\r\n"
  "float4x4 world   : World;\r\n"
  "float4x4 viewi   : ViewI;\r\n"
  "float4x4 worldit : WorldIT;\r\n"
  "\r\n"
  "#ifndef PI\r\n"
  "#define PI  3.14159265358979f\r\n"
  "#endif\r\n"
  "\r\n"
  "// \r\n"
  "// TWEAKABLES\r\n"
  "//\r\n"
  "\r\n"
  "float4 diffuse\r\n"
  "<\r\n"
  "  string UIDescription   = \"diffuse material color\";\r\n"
  "  string UIWidget   = \"ColorPicker\";\r\n"
  "> = float4( float3(0.8f), 1.0f );\r\n"
  "\r\n"
  "float4 ambient\r\n"
  "<\r\n"
  "  string UIDescription   = \"ambient material color\";\r\n"
  "  string UIWidget   = \"ColorPicker\";\r\n"
  "> = float4( float3(0.2f), 1.0f );\r\n"
  "\r\n"
  "float4 specular\r\n"
  "<\r\n"
  "  string UIDescription   = \"specular material color\";\r\n"
  "  string UIWidget   = \"ColorPicker\";\r\n"
  "> = float4( float3(1.f), 1.0f );\r\n"
  "\r\n"
  "float4 emissive\r\n"
  "<\r\n"
  "  string UIDescription   = \"emissive material color\";\r\n"
  "  string UIWidget   = \"ColorPicker\";\r\n"
  "> = float4( float3(0.f), 1.0f );\r\n"
  "\r\n"
  "float shininess\r\n"
  "<\r\n"
  "  string UIDescription   = \"material shininess value\";\r\n"
  "  string UIControl    = \"Slider\";\r\n"
  "  float UIMin  = 0.0;\r\n"
  "  float UIMax  = 1.0;\r\n"
  "  float UIStep = 0.01;\r\n"
  "  float UIStepPower = 2;\r\n"
  "> = 0.21f;\r\n"
  "\r\n"
  "float opacity\r\n"
  "<\r\n"
  "  string UIDescription   = \"material opacity value\";\r\n"
  "  string UIControl    = \"Slider\";\r\n"
  "  float UIMin  = 0.0;\r\n"
  "  float UIMax  = 1.0;\r\n"
  "  float UIStep = 0.1;\r\n"
  "> = 1.f;\r\n"
  "\r\n"
  "struct NVSGScene\r\n"
  "{\r\n"
  "  float4 ambient;\r\n"
  "  int    frameNumber;\r\n"
  "};\r\n"
  "\r\n"
  "NVSGScene scene;\r\n"
  "\r\n"
  "//! The NVSGLight structure specifies the data layout for an effect light "
  "parameter.\r\n"
  "/** A parameter of type NVSGLight will be automatic bound to a tree light "
  "in SceniX. */\r\n"
  "struct NVSGLight\r\n"
  "{\r\n"
  "  float4 ambient;                //!< Specifies the ambient RGBA intensity of the light.\r\n"
  "  float4 diffuse;                //!< Specifies the diffuse RGBA intensity of the light.\r\n"
  "  float4 specular;               //!< Specifies the specular RGBA intensity of the light.\r\n"
  "  float4 position;               //!< Specifies the light position in world coordinates.\r\n"
  "  float4 direction;              //!< Specifies the light direction in world coordinates.\r\n"
  "  float  spotExponent;           //!< Specifies the intensity distribution of the light.\r\n"
  "  float  spotCutoff;             //!< Specifies the maximum spread angle of the light.\r\n"
  "  float  constantAttenuation;    //!< Specifies the constant light attenuation factor.\r\n"
  "  float  linearAttenuation;      //!< Specifies the linear light attenuation factor.\r\n"
  "  float  quadraticAttenuation;   //!< Specifies the quadratic light attenuation factor.\r\n"
  "};\r\n"
  "\r\n"
  "NVSGLight lights[];\r\n"
  " \r\n"
  "// we only have positions and normals\r\n"
  "struct app2vert\r\n"
  "{\r\n"
  "  float3 position : POSITION; // in object space\r\n"
  "  float3 normal   : NORMAL; \r\n"
  "};\r\n"
  "\r\n"
  "struct vert2frag\r\n"
  "{\r\n"
  "  float4 position : POSITION; // in projection space\r\n"
  "  float4 fcolor    : COLOR0;\r\n"
  "  float4 bcolor    : COLOR1;\r\n"
  "};\r\n"
  "\r\n"
  "//\r\n"
  "// library functions\r\n"
  "//\r\n"
  "\r\n"
  "// lighting calculations\r\n"
  "void lighting( NVSGLight light\r\n"
  "             , float3 position\r\n"
  "             , float3 normal\r\n"
  "             , float3 viewVector\r\n"
  "             , float shiny\r\n"
  "             , in out float3 ambient\r\n"
  "             , in out float3 diffuse\r\n"
  "             , in out float3 specular\r\n"
  "             , in out float3 bdiffuse\r\n"
  "             , in out float3 bspecular\r\n"
  "             )\r\n"
  "{\r\n"
  "  float3 L;\r\n"
  "  float attenuationSpotProduct = 1.0f;\r\n"
  "  if ( light.position.w == 0.0f )\r\n"
  "  {\r\n"
  "    // directed light\r\n"
  "    L = normalize(light.position.xyz);\r\n"
  "  }\r\n"
  "  else\r\n"
  "  {\r\n"
  "    // point/spot light\r\n"
  "    L = light.position.xyz - position;\r\n"
  "    float L_dist = length(L);\r\n"
  "    L = L/L_dist;  // normalize\r\n"
  "\r\n"
  "    // attenuation and spot factors\r\n"
  "    attenuationSpotProduct = 1.0f / (light.constantAttenuation + (light.linearAttenuation + light.quadraticAttenuation * L_dist) * L_dist);\r\n"
  "\r\n"
  "    if ( light.spotCutoff < 180.0f ) // spot light\r\n"
  "    {\r\n"
  "      float spot = max( 0.0f, dot( -L, light.direction.xyz ) );\r\n"
  "      attenuationSpotProduct *= (spot > cos(light.spotCutoff * PI / 180.0f)) ? pow(spot, light.spotExponent) : 1.0f; \r\n"
  "    }\r\n"
  "  }\r\n"
  "\r\n"
  "  // ambient term\r\n"
  "  ambient = light.ambient.xyz * attenuationSpotProduct;\r\n"
  "\r\n"
  "  //\r\n"
  "  // NOTE: we compute both front and back diffuse and specular values for two sided lighting\r\n"
  "  //\r\n"
  "  // diffuse term\r\n"
  "  float dfactor = max(dot(normal,L), 0);\r\n"
  "  float bdfactor = max(dot(-normal,L), 0);\r\n"
  "  diffuse = light.diffuse.xyz * dfactor * attenuationSpotProduct;\r\n"
  "  bdiffuse = light.diffuse.xyz * bdfactor * attenuationSpotProduct;\r\n"
  "\r\n"
  "  // specular term\r\n"
  "  float sfactor = 0.0f;\r\n"
  "  float bsfactor = 0.0f;\r\n"
  "\r\n"
  "  float3 H = normalize(L+viewVector);\r\n"
  "  if (dfactor > 0)\r\n"
  "  {\r\n"
  "    sfactor = pow(max(dot(normal,H),0), shiny);\r\n"
  "  }\r\n"
  "\r\n"
  "  specular = light.specular.xyz * sfactor * attenuationSpotProduct;\r\n"
  "  if (bdfactor > 0)\r\n"
  "  {\r\n"
  "    bsfactor = pow(max(dot(-normal,H),0), shiny);\r\n"
  "  }\r\n"
  "\r\n"
  "  bspecular = light.specular.xyz * bsfactor * attenuationSpotProduct;\r\n"
  "}\r\n"
  "\r\n"
  "void lightIntensity( float shiny,\r\n"
  "                     float3 P,\r\n"
  "                     float3 V,\r\n"
  "                     float3 N,\r\n"
  "                     in out float3 ambientSum,\r\n"
  "                     in out float3 diffuseSum,\r\n"
  "                     in out float3 specularSum,\r\n"
  "                     in out float3 bdiffuseSum,\r\n"
  "                     in out float3 bspecularSum )\r\n"
  "{\r\n"
  "\r\n"
  " for ( int i=0; i<lights.length; ++i )\r\n"
  " {\r\n"
  "   float3 ambientLight;\r\n"
  "   float3 diffuseLight;\r\n"
  "   float3 specularLight;\r\n"
  "   float3 bdiffuseLight;\r\n"
  "   float3 bspecularLight;\r\n"
  "\r\n"
  "   lighting( lights[i], P, N, V, shiny, ambientLight, diffuseLight, specularLight, bdiffuseLight, bspecularLight );\r\n"
  "\r\n"
  "   // sum up\r\n"
  "   ambientSum += ambientLight;\r\n"
  "   diffuseSum += diffuseLight;\r\n"
  "   specularSum += specularLight;\r\n"
  "   bdiffuseSum += bdiffuseLight;\r\n"
  "   bspecularSum += bspecularLight;\r\n"
  " }\r\n"
  "}\r\n"
  "\r\n"
  "vert2frag vertex( app2vert a2v )\r\n"
  "{                  \r\n"
  "  vert2frag OUT;\r\n"
  "\r\n"
  "  float4 position = float4( a2v.position, 1.f );\r\n"
  "\r\n"
  "  OUT.position = mul( worldvp, position );\r\n"
  "\r\n"
  "  float3 P = mul( world, position ).xyz;\r\n"
  "  float3 V = normalize( mul(viewi, float4(0,0,0,1)).xyz - P );\r\n"
  "  float3 N = normalize( mul(worldit, float4(a2v.normal,0)).xyz );\r\n"
  "\r\n"
  "  // compute lighting\r\n"
  "  float3 ambientLight = 0;\r\n"
  "  float3 diffuseLight = 0;\r\n"
  "  float3 specularLight = 0;\r\n"
  "  float3 bdiffuseLight = 0;\r\n"
  "  float3 bspecularLight = 0;\r\n"
  "\r\n"
  "  lightIntensity( shininess * 127.f + 1.f,\r\n"
  "                  P,\r\n"
  "                  V,\r\n"
  "                  N,\r\n"
  "                  ambientLight,\r\n"
  "                  diffuseLight,\r\n"
  "                  specularLight,\r\n"
  "                  bdiffuseLight,\r\n"
  "                  bspecularLight );\r\n"
  "\r\n"
  "  float4 tsum = scene.ambient * ambient * float4( ambientLight, 0.f ) +\r\n"
  "                float4( emissive.rgb, 0.f ) +\r\n"
  "                // add in opacity here too\r\n"
  "                float4( 0.f, 0.f, 0.f, opacity );\r\n"
  "\r\n"
  "  OUT.fcolor = tsum +\r\n"
  "               diffuse * float4( diffuseLight, 0.f ) + \r\n"
  "               specular * float4( specularLight, 0.f );\r\n"
  "\r\n"
  "  OUT.bcolor = tsum +\r\n"
  "               diffuse * float4( bdiffuseLight, 0.f ) + \r\n"
  "               specular * float4( bspecularLight, 0.f );\r\n"
  "\r\n"
  "  return OUT;\r\n"
  "}\r\n"
  "\r\n"
  "float4 fragment( vert2frag v2f, float facing : FACE ) : COLOR\r\n"
  "{\r\n"
  "  return (facing < 0.0 ) ? v2f.bcolor : v2f.fcolor;\r\n"
  "}\r\n"
  "\r\n"
  "technique opaque\r\n"
  "{\r\n"
  "  pass\r\n"
  "  {\r\n"
  "    CullFaceEnable = false;\r\n"
  "    VertexProgram   = compile latest vertex();\r\n"
  "    FragmentProgram = compile latest fragment();\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "technique transparent\r\n"
  "{\r\n"
  "  pass\r\n"
  "  {\r\n"
  "    BlendEnable = true;\r\n"
  "    BlendFunc   = int2( SrcAlpha, OneMinusSrcAlpha );\r\n"
  "    CullFaceEnable = false;\r\n"
  "    VertexProgram   = compile latest vertex();\r\n"
  "    FragmentProgram = compile latest fragment();\r\n"
  "  }\r\n"
  "}\r\n"
  "\r\n"
  "";
